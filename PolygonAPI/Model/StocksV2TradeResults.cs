/* 
 * Polygon API
 *
 * The future of fintech.
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = PolygonIO.Client.SwaggerDateConverter;

namespace PolygonIO.Model
{
    /// <summary>
    /// StocksV2TradeResults
    /// </summary>
    [DataContract]
        public partial class StocksV2TradeResults :  IEquatable<StocksV2TradeResults>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="StocksV2TradeResults" /> class.
        /// </summary>
        /// <param name="i">The original ID of the trade.  This is used when there is a trade correction to indicate the ID of the corrected trade..</param>
        /// <param name="x">The exchange ID. See &lt;a href&#x3D;\&quot;https://polygon.io/docs/get_v1_meta_exchanges_anchor\&quot; alt&#x3D;\&quot;Exchanges\&quot;&gt;Exchanges&lt;/a&gt; for Polygon.io&#x27;s mapping of exchange IDs..</param>
        /// <param name="p">The price of the trade. This is the actual dollar value per whole share of this trade.  A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00..</param>
        /// <param name="i">The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID. .</param>
        /// <param name="e">The trade correction indicator..</param>
        /// <param name="r">The ID for the Trade Reporting Facility where the trade took place..</param>
        /// <param name="t">The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it..</param>
        /// <param name="y">The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange..</param>
        /// <param name="f">The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message..</param>
        /// <param name="q">The sequence number representing the sequence in which trade events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11). .</param>
        /// <param name="c">The trade conditions.  These are the conditions of this message.  See &lt;a href&#x3D;\&quot;https://polygon.io/docs/get_v1_meta_conditions__ticktype__anchor\&quot; alt&#x3D;\&quot;Condition Mappings\&quot;&gt;Condition Mappings&lt;/a&gt; for a mapping to exchange conditions..</param>
        /// <param name="s">The size of a trade (also known as volume) as a number of whole shares traded..</param>
        /// <param name="z">There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 &#x3D; A, 2 &#x3D; B, 3 &#x3D; C. * Tape A is NYSE listed securities * Tape B is NYSE ARCA / NYSE American * Tape C is NASDAQ .</param>
        public StocksV2TradeResults(int? oi = default(int?), int? x = default(int?), double? p = default(double?), string i = default(string), int? e = default(int?), int? r = default(int?), int? t = default(int?), int? y = default(int?), int? f = default(int?), long? q = default(long?), List<int?> c = default(List<int?>), int? s = default(int?), int? z = default(int?))
        {
            this.oI = oi;
            this.X = x;
            this.P = p;
            this.I = i;
            this.E = e;
            this.R = r;
            this.T = t;
            this.Y = y;
            this.F = f;
            this.Q = q;
            this.C = c;
            this.S = s;
            this.Z = z;
        }
        
        /// <summary>
        /// The original ID of the trade.  This is used when there is a trade correction to indicate the ID of the corrected trade.
        /// </summary>
        /// <value>The original ID of the trade.  This is used when there is a trade correction to indicate the ID of the corrected trade.</value>
        [DataMember(Name="I", EmitDefaultValue=false)]
        public int? oI { get; set; }

        /// <summary>
        /// The exchange ID. See &lt;a href&#x3D;\&quot;https://polygon.io/docs/get_v1_meta_exchanges_anchor\&quot; alt&#x3D;\&quot;Exchanges\&quot;&gt;Exchanges&lt;/a&gt; for Polygon.io&#x27;s mapping of exchange IDs.
        /// </summary>
        /// <value>The exchange ID. See &lt;a href&#x3D;\&quot;https://polygon.io/docs/get_v1_meta_exchanges_anchor\&quot; alt&#x3D;\&quot;Exchanges\&quot;&gt;Exchanges&lt;/a&gt; for Polygon.io&#x27;s mapping of exchange IDs.</value>
        [DataMember(Name="x", EmitDefaultValue=false)]
        public int? X { get; set; }

        /// <summary>
        /// The price of the trade. This is the actual dollar value per whole share of this trade.  A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.
        /// </summary>
        /// <value>The price of the trade. This is the actual dollar value per whole share of this trade.  A trade of 100 shares with a price of $2.00 would be worth a total dollar value of $200.00.</value>
        [DataMember(Name="p", EmitDefaultValue=false)]
        public double? P { get; set; }

        /// <summary>
        /// The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID. 
        /// </summary>
        /// <value>The Trade ID which uniquely identifies a trade. These are unique per combination of ticker, exchange, and TRF. For example: A trade for AAPL executed on NYSE and a trade for AAPL executed on NASDAQ could potentially have the same Trade ID. </value>
        [DataMember(Name="i", EmitDefaultValue=false)]
        public string I { get; set; }

        /// <summary>
        /// The trade correction indicator.
        /// </summary>
        /// <value>The trade correction indicator.</value>
        [DataMember(Name="e", EmitDefaultValue=false)]
        public int? E { get; set; }

        /// <summary>
        /// The ID for the Trade Reporting Facility where the trade took place.
        /// </summary>
        /// <value>The ID for the Trade Reporting Facility where the trade took place.</value>
        [DataMember(Name="r", EmitDefaultValue=false)]
        public int? R { get; set; }

        /// <summary>
        /// The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
        /// </summary>
        /// <value>The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.</value>
        [DataMember(Name="t", EmitDefaultValue=false)]
        public int? T { get; set; }

        /// <summary>
        /// The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
        /// </summary>
        /// <value>The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.</value>
        [DataMember(Name="y", EmitDefaultValue=false)]
        public int? Y { get; set; }

        /// <summary>
        /// The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
        /// </summary>
        /// <value>The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.</value>
        [DataMember(Name="f", EmitDefaultValue=false)]
        public int? F { get; set; }

        /// <summary>
        /// The sequence number representing the sequence in which trade events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11). 
        /// </summary>
        /// <value>The sequence number representing the sequence in which trade events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11). </value>
        [DataMember(Name="q", EmitDefaultValue=false)]
        public long? Q { get; set; }

        /// <summary>
        /// The trade conditions.  These are the conditions of this message.  See &lt;a href&#x3D;\&quot;https://polygon.io/docs/get_v1_meta_conditions__ticktype__anchor\&quot; alt&#x3D;\&quot;Condition Mappings\&quot;&gt;Condition Mappings&lt;/a&gt; for a mapping to exchange conditions.
        /// </summary>
        /// <value>The trade conditions.  These are the conditions of this message.  See &lt;a href&#x3D;\&quot;https://polygon.io/docs/get_v1_meta_conditions__ticktype__anchor\&quot; alt&#x3D;\&quot;Condition Mappings\&quot;&gt;Condition Mappings&lt;/a&gt; for a mapping to exchange conditions.</value>
        [DataMember(Name="c", EmitDefaultValue=false)]
        public List<int?> C { get; set; }

        /// <summary>
        /// The size of a trade (also known as volume) as a number of whole shares traded.
        /// </summary>
        /// <value>The size of a trade (also known as volume) as a number of whole shares traded.</value>
        [DataMember(Name="s", EmitDefaultValue=false)]
        public int? S { get; set; }

        /// <summary>
        /// There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 &#x3D; A, 2 &#x3D; B, 3 &#x3D; C. * Tape A is NYSE listed securities * Tape B is NYSE ARCA / NYSE American * Tape C is NASDAQ 
        /// </summary>
        /// <value>There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 &#x3D; A, 2 &#x3D; B, 3 &#x3D; C. * Tape A is NYSE listed securities * Tape B is NYSE ARCA / NYSE American * Tape C is NASDAQ </value>
        [DataMember(Name="z", EmitDefaultValue=false)]
        public int? Z { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class StocksV2TradeResults {\n");
            sb.Append("  oI: ").Append(oI).Append("\n");
            sb.Append("  X: ").Append(X).Append("\n");
            sb.Append("  P: ").Append(P).Append("\n");
            sb.Append("  I: ").Append(I).Append("\n");
            sb.Append("  E: ").Append(E).Append("\n");
            sb.Append("  R: ").Append(R).Append("\n");
            sb.Append("  T: ").Append(T).Append("\n");
            sb.Append("  Y: ").Append(Y).Append("\n");
            sb.Append("  F: ").Append(F).Append("\n");
            sb.Append("  Q: ").Append(Q).Append("\n");
            sb.Append("  C: ").Append(C).Append("\n");
            sb.Append("  S: ").Append(S).Append("\n");
            sb.Append("  Z: ").Append(Z).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as StocksV2TradeResults);
        }

        /// <summary>
        /// Returns true if StocksV2TradeResults instances are equal
        /// </summary>
        /// <param name="input">Instance of StocksV2TradeResults to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(StocksV2TradeResults input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.oI == input.oI ||
                    (this.oI != null &&
                    this.oI.Equals(input.oI))
                ) && 
                (
                    this.X == input.X ||
                    (this.X != null &&
                    this.X.Equals(input.X))
                ) && 
                (
                    this.P == input.P ||
                    (this.P != null &&
                    this.P.Equals(input.P))
                ) && 
                (
                    this.I == input.I ||
                    (this.I != null &&
                    this.I.Equals(input.I))
                ) && 
                (
                    this.E == input.E ||
                    (this.E != null &&
                    this.E.Equals(input.E))
                ) && 
                (
                    this.R == input.R ||
                    (this.R != null &&
                    this.R.Equals(input.R))
                ) && 
                (
                    this.T == input.T ||
                    (this.T != null &&
                    this.T.Equals(input.T))
                ) && 
                (
                    this.Y == input.Y ||
                    (this.Y != null &&
                    this.Y.Equals(input.Y))
                ) && 
                (
                    this.F == input.F ||
                    (this.F != null &&
                    this.F.Equals(input.F))
                ) && 
                (
                    this.Q == input.Q ||
                    (this.Q != null &&
                    this.Q.Equals(input.Q))
                ) && 
                (
                    this.C == input.C ||
                    this.C != null &&
                    input.C != null &&
                    this.C.SequenceEqual(input.C)
                ) && 
                (
                    this.S == input.S ||
                    (this.S != null &&
                    this.S.Equals(input.S))
                ) && 
                (
                    this.Z == input.Z ||
                    (this.Z != null &&
                    this.Z.Equals(input.Z))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.oI != null)
                    hashCode = hashCode * 59 + this.oI.GetHashCode();
                if (this.X != null)
                    hashCode = hashCode * 59 + this.X.GetHashCode();
                if (this.P != null)
                    hashCode = hashCode * 59 + this.P.GetHashCode();
                if (this.I != null)
                    hashCode = hashCode * 59 + this.I.GetHashCode();
                if (this.E != null)
                    hashCode = hashCode * 59 + this.E.GetHashCode();
                if (this.R != null)
                    hashCode = hashCode * 59 + this.R.GetHashCode();
                if (this.T != null)
                    hashCode = hashCode * 59 + this.T.GetHashCode();
                if (this.Y != null)
                    hashCode = hashCode * 59 + this.Y.GetHashCode();
                if (this.F != null)
                    hashCode = hashCode * 59 + this.F.GetHashCode();
                if (this.Q != null)
                    hashCode = hashCode * 59 + this.Q.GetHashCode();
                if (this.C != null)
                    hashCode = hashCode * 59 + this.C.GetHashCode();
                if (this.S != null)
                    hashCode = hashCode * 59 + this.S.GetHashCode();
                if (this.Z != null)
                    hashCode = hashCode * 59 + this.Z.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
