/* 
 * Polygon API
 *
 * The future of fintech.
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = PolygonIO.Client.SwaggerDateConverter;

namespace PolygonIO.Model
{
    /// <summary>
    /// StocksV2NBBOResults
    /// </summary>
    [DataContract]
        public partial class StocksV2NBBOResults :  IEquatable<StocksV2NBBOResults>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="StocksV2NBBOResults" /> class.
        /// </summary>
        /// <param name="t">The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it..</param>
        /// <param name="y">The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange..</param>
        /// <param name="f">The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message..</param>
        /// <param name="q">The sequence number represents the sequence in which message events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11). .</param>
        /// <param name="c">A list of condition codes..</param>
        /// <param name="i">The indicators.  For more information, see our glossary of &lt;a href&#x3D;\&quot;https://polygon.io/glossary/us/stocks/conditions-indicators\&quot; alt&#x3D;\&quot;Conditions and Indicators Glossary\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Conditions and Indicators&lt;/a&gt;..</param>
        /// <param name="p">The bid price..</param>
        /// <param name="x">The bid Exchange ID..</param>
        /// <param name="s">The bid size. This represents the number of round lot orders at the given bid price. The normal round lot size is 100 shares. A bid size of 2 means there are 200 shares for purchase at the given bid price..</param>
        /// <param name="p">The ask price..</param>
        /// <param name="x">The ask Exchange ID..</param>
        /// <param name="s">The ask size. This represents the number of round lot orders at the given ask price. The normal round lot size is 100 shares. An ask size of 2 means there are 200 shares available to purchase at the given ask price..</param>
        /// <param name="z">There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 &#x3D; A, 2 &#x3D; B, 3 &#x3D; C. * Tape A is NYSE listed securities * Tape B is NYSE ARCA / NYSE American * Tape C is NASDAQ .</param>
        public StocksV2NBBOResults(int? t = default(int?), int? y = default(int?), int? f = default(int?), long? q = default(long?), List<int?> c = default(List<int?>), List<int?> i = default(List<int?>), double? bp = default(double?), int? bx = default(int?), int? bs = default(int?), double? ap = default(double?), int? ax = default(int?), int? a_s = default(int?), int? z = default(int?))
        {
            this.T = t;
            this.Y = y;
            this.F = f;
            this.Q = q;
            this.C = c;
            this.I = i;
            this.bP = bp;
            this.bX = bx;
            this.bS = bs;
            this.aP = ap;
            this.aX = ax;
            this.aS = a_s;
            this.Z = z;
        }
        
        /// <summary>
        /// The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.
        /// </summary>
        /// <value>The nanosecond accuracy SIP Unix Timestamp. This is the timestamp of when the SIP received this message from the exchange which produced it.</value>
        [DataMember(Name="t", EmitDefaultValue=false)]
        public int? T { get; set; }

        /// <summary>
        /// The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.
        /// </summary>
        /// <value>The nanosecond accuracy Participant/Exchange Unix Timestamp. This is the timestamp of when the quote was actually generated at the exchange.</value>
        [DataMember(Name="y", EmitDefaultValue=false)]
        public int? Y { get; set; }

        /// <summary>
        /// The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.
        /// </summary>
        /// <value>The nanosecond accuracy TRF(Trade Reporting Facility) Unix Timestamp. This is the timestamp of when the trade reporting facility received this message.</value>
        [DataMember(Name="f", EmitDefaultValue=false)]
        public int? F { get; set; }

        /// <summary>
        /// The sequence number represents the sequence in which message events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11). 
        /// </summary>
        /// <value>The sequence number represents the sequence in which message events happened. These are increasing and unique per ticker symbol, but will not always be sequential (e.g., 1, 2, 6, 9, 10, 11). </value>
        [DataMember(Name="q", EmitDefaultValue=false)]
        public long? Q { get; set; }

        /// <summary>
        /// A list of condition codes.
        /// </summary>
        /// <value>A list of condition codes.</value>
        [DataMember(Name="c", EmitDefaultValue=false)]
        public List<int?> C { get; set; }

        /// <summary>
        /// The indicators.  For more information, see our glossary of &lt;a href&#x3D;\&quot;https://polygon.io/glossary/us/stocks/conditions-indicators\&quot; alt&#x3D;\&quot;Conditions and Indicators Glossary\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Conditions and Indicators&lt;/a&gt;.
        /// </summary>
        /// <value>The indicators.  For more information, see our glossary of &lt;a href&#x3D;\&quot;https://polygon.io/glossary/us/stocks/conditions-indicators\&quot; alt&#x3D;\&quot;Conditions and Indicators Glossary\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Conditions and Indicators&lt;/a&gt;.</value>
        [DataMember(Name="i", EmitDefaultValue=false)]
        public List<int?> I { get; set; }

        /// <summary>
        /// The bid price.
        /// </summary>
        /// <value>The bid price.</value>
        [DataMember(Name="p", EmitDefaultValue=false)]
        public double? bP { get; set; }

        /// <summary>
        /// The bid Exchange ID.
        /// </summary>
        /// <value>The bid Exchange ID.</value>
        [DataMember(Name="x", EmitDefaultValue=false)]
        public int? bX { get; set; }

        /// <summary>
        /// The bid size. This represents the number of round lot orders at the given bid price. The normal round lot size is 100 shares. A bid size of 2 means there are 200 shares for purchase at the given bid price.
        /// </summary>
        /// <value>The bid size. This represents the number of round lot orders at the given bid price. The normal round lot size is 100 shares. A bid size of 2 means there are 200 shares for purchase at the given bid price.</value>
        [DataMember(Name="s", EmitDefaultValue=false)]
        public int? bS { get; set; }

        /// <summary>
        /// The ask price.
        /// </summary>
        /// <value>The ask price.</value>
        [DataMember(Name="P", EmitDefaultValue=false)]
        public double? aP { get; set; }

        /// <summary>
        /// The ask Exchange ID.
        /// </summary>
        /// <value>The ask Exchange ID.</value>
        [DataMember(Name="X", EmitDefaultValue=false)]
        public int? aX { get; set; }

        /// <summary>
        /// The ask size. This represents the number of round lot orders at the given ask price. The normal round lot size is 100 shares. An ask size of 2 means there are 200 shares available to purchase at the given ask price.
        /// </summary>
        /// <value>The ask size. This represents the number of round lot orders at the given ask price. The normal round lot size is 100 shares. An ask size of 2 means there are 200 shares available to purchase at the given ask price.</value>
        [DataMember(Name="S", EmitDefaultValue=false)]
        public int? aS { get; set; }

        /// <summary>
        /// There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 &#x3D; A, 2 &#x3D; B, 3 &#x3D; C. * Tape A is NYSE listed securities * Tape B is NYSE ARCA / NYSE American * Tape C is NASDAQ 
        /// </summary>
        /// <value>There are 3 tapes which define which exchange the ticker is listed on. These are integers in our objects which represent the letter of the alphabet. Eg: 1 &#x3D; A, 2 &#x3D; B, 3 &#x3D; C. * Tape A is NYSE listed securities * Tape B is NYSE ARCA / NYSE American * Tape C is NASDAQ </value>
        [DataMember(Name="z", EmitDefaultValue=false)]
        public int? Z { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class StocksV2NBBOResults {\n");
            sb.Append("  T: ").Append(T).Append("\n");
            sb.Append("  Y: ").Append(Y).Append("\n");
            sb.Append("  F: ").Append(F).Append("\n");
            sb.Append("  Q: ").Append(Q).Append("\n");
            sb.Append("  C: ").Append(C).Append("\n");
            sb.Append("  I: ").Append(I).Append("\n");
            sb.Append("  bP: ").Append(bP).Append("\n");
            sb.Append("  bX: ").Append(bX).Append("\n");
            sb.Append("  bS: ").Append(bS).Append("\n");
            sb.Append("  aP: ").Append(aP).Append("\n");
            sb.Append("  aX: ").Append(aX).Append("\n");
            sb.Append("  aS: ").Append(aS).Append("\n");
            sb.Append("  Z: ").Append(Z).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as StocksV2NBBOResults);
        }

        /// <summary>
        /// Returns true if StocksV2NBBOResults instances are equal
        /// </summary>
        /// <param name="input">Instance of StocksV2NBBOResults to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(StocksV2NBBOResults input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.T == input.T ||
                    (this.T != null &&
                    this.T.Equals(input.T))
                ) && 
                (
                    this.Y == input.Y ||
                    (this.Y != null &&
                    this.Y.Equals(input.Y))
                ) && 
                (
                    this.F == input.F ||
                    (this.F != null &&
                    this.F.Equals(input.F))
                ) && 
                (
                    this.Q == input.Q ||
                    (this.Q != null &&
                    this.Q.Equals(input.Q))
                ) && 
                (
                    this.C == input.C ||
                    this.C != null &&
                    input.C != null &&
                    this.C.SequenceEqual(input.C)
                ) && 
                (
                    this.I == input.I ||
                    this.I != null &&
                    input.I != null &&
                    this.I.SequenceEqual(input.I)
                ) && 
                (
                    this.bP == input.bP ||
                    (this.bP != null &&
                    this.bP.Equals(input.bP))
                ) && 
                (
                    this.bX == input.bX ||
                    (this.bX != null &&
                    this.bX.Equals(input.bX))
                ) && 
                (
                    this.bS == input.bS ||
                    (this.bS != null &&
                    this.bS.Equals(input.bS))
                ) && 
                (
                    this.aP == input.aP ||
                    (this.aP != null &&
                    this.aP.Equals(input.aP))
                ) && 
                (
                    this.aX == input.aX ||
                    (this.aX != null &&
                    this.aX.Equals(input.aX))
                ) && 
                (
                    this.aS == input.aS ||
                    (this.aS != null &&
                    this.aS.Equals(input.aS))
                ) && 
                (
                    this.Z == input.Z ||
                    (this.Z != null &&
                    this.Z.Equals(input.Z))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.T != null)
                    hashCode = hashCode * 59 + this.T.GetHashCode();
                if (this.Y != null)
                    hashCode = hashCode * 59 + this.Y.GetHashCode();
                if (this.F != null)
                    hashCode = hashCode * 59 + this.F.GetHashCode();
                if (this.Q != null)
                    hashCode = hashCode * 59 + this.Q.GetHashCode();
                if (this.C != null)
                    hashCode = hashCode * 59 + this.C.GetHashCode();
                if (this.I != null)
                    hashCode = hashCode * 59 + this.I.GetHashCode();
                if (this.bP != null)
                    hashCode = hashCode * 59 + this.bP.GetHashCode();
                if (this.bX != null)
                    hashCode = hashCode * 59 + this.bX.GetHashCode();
                if (this.bS != null)
                    hashCode = hashCode * 59 + this.bS.GetHashCode();
                if (this.aP != null)
                    hashCode = hashCode * 59 + this.aP.GetHashCode();
                if (this.aX != null)
                    hashCode = hashCode * 59 + this.aX.GetHashCode();
                if (this.aS != null)
                    hashCode = hashCode * 59 + this.aS.GetHashCode();
                if (this.Z != null)
                    hashCode = hashCode * 59 + this.Z.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
